Log file created at 2025-05-06 12:03:04.459784

Log id: c12dead1-ba0c-4b51-bf0e-df4f6b2770e8


 Time: 2025-05-06 12:03:04.459923, Log:Read file compression.c
 Time: 2025-05-06 12:03:04.474015, Log:Starting compression algorithm evolution...
 Time: 2025-05-06 12:03:04.474070, Log:Model: meta-llama/Llama-3.3-70B-Instruct, Temperature: 0.6, Reasoning: False 
 Time: 2025-05-06 12:03:04.474089, Log:Extracting compression and decompression functions
 Time: 2025-05-06 12:03:04.474278, Log:Compression and decompression functions extracted.
 Time: 2025-05-06 12:03:04.474339, Log:Generating initial 2 individuals asynchronously...
 Time: 2025-05-06 12:03:04.474389, Log:Evolving functions with LLM for generation 0, individual 1
 Time: 2025-05-06 12:03:04.474404, Log:Creating LLM prompt for generation
 Time: 2025-05-06 12:03:04.477205, Log:Calling LLM asynchronously...
 Time: 2025-05-06 12:03:04.479942, Log:Evolving functions with LLM for generation 0, individual 2
 Time: 2025-05-06 12:03:04.480648, Log:Creating LLM prompt for generation
 Time: 2025-05-06 12:03:04.483906, Log:Calling LLM asynchronously...
 Time: 2025-05-06 12:04:34.775773, Log:LLM response: 


 //INIZIO_FUNZIONE_COMPRESSIONE
unsigned char* compress(const unsigned char* data, size_t data_size, size_t* compressed_size) {
    unsigned char* compressed = (unsigned char*)malloc(data_size * 2);
    if (compressed == NULL) return NULL;

    size_t compressed_index = 0;
    size_t i = 0;
    unsigned char previous_char = 0;
    unsigned char count = 0;

    while (i < data_size) {
        unsigned char current = data[i];
        if (current == previous_char) {
            count++;
        } else {
            if (count > 0) {
                if (count > 1) {
                    compressed[compressed_index++] = count;
                    compressed[compressed_index++] = previous_char;
                } else {
                    compressed[compressed_index++] = previous_char;
                }
            }
            previous_char = current;
            count = 1;
        }
        i++;
    }

    if (count > 0) {
        if (count > 1) {
            compressed[compressed_index++] = count;
            compressed[compressed_index++] = previous_char;
        } else {
            compressed[compressed_index++] = previous_char;
        }
    }

    compressed = (unsigned char*)realloc(compressed, compressed_index);
    *compressed_size = compressed_index;

    return compressed;
}
//FINE_FUNZIONE_COMPRESSIONE

//INIZIO_FUNZIONE_DECOMPRESSIONE
unsigned char* decompress(const unsigned char* compressed_data, size_t compressed_size, size_t* decompressed_size) {
    size_t max_size = compressed_size * 255; 
    unsigned char* decompressed = (unsigned char*)malloc(max_size);
    if (decompressed == NULL) return NULL;

    size_t decompressed_index = 0;
    size_t i = 0;

    while (i < compressed_size) {
        if (i + 1 < compressed_size && compressed_data[i] > 1) {
            unsigned char count = compressed_data[i++];
            unsigned char value = compressed_data[i++];

            for (unsigned char j = 0; j < count; j++) {
                decompressed[decompressed_index++] = value;
            }
        } else {
            decompressed[decompressed_index++] = compressed_data[i++];
        }
    }

    decompressed = (unsigned char*)realloc(decompressed, decompressed_index);
    *decompressed_size = decompressed_index;

    return decompressed;
}
//FINE_FUNZIONE_DECOMPRESSIONE 



 Time: 2025-05-06 12:04:34.775875, Log:Extracting evolved functions from LLM response
 Time: 2025-05-06 12:04:34.775913, Log:Compression function extracted: 


 unsigned char* compress(const unsigned char* data, size_t data_size, size_t* compressed_size) {
    unsigned char* compressed = (unsigned char*)malloc(data_size * 2);
    if (compressed == NULL) return NULL;

    size_t compressed_index = 0;
    size_t i = 0;
    unsigned char previous_char = 0;
    unsigned char count = 0;

    while (i < data_size) {
        unsigned char current = data[i];
        if (current == previous_char) {
            count++;
        } else {
            if (count > 0) {
                if (count > 1) {
                    compressed[compressed_index++] = count;
                    compressed[compressed_index++] = previous_char;
                } else {
                    compressed[compressed_index++] = previous_char;
                }
            }
            previous_char = current;
            count = 1;
        }
        i++;
    }

    if (count > 0) {
        if (count > 1) {
            compressed[compressed_index++] = count;
            compressed[compressed_index++] = previous_char;
        } else {
            compressed[compressed_index++] = previous_char;
        }
    }

    compressed = (unsigned char*)realloc(compressed, compressed_index);
    *compressed_size = compressed_index;

    return compressed;
}
 



 Time: 2025-05-06 12:04:34.775942, Log:Decompression function extracted: 


 unsigned char* decompress(const unsigned char* compressed_data, size_t compressed_size, size_t* decompressed_size) {
    size_t max_size = compressed_size * 255; 
    unsigned char* decompressed = (unsigned char*)malloc(max_size);
    if (decompressed == NULL) return NULL;

    size_t decompressed_index = 0;
    size_t i = 0;

    while (i < compressed_size) {
        if (i + 1 < compressed_size && compressed_data[i] > 1) {
            unsigned char count = compressed_data[i++];
            unsigned char value = compressed_data[i++];

            for (unsigned char j = 0; j < count; j++) {
                decompressed[decompressed_index++] = value;
            }
        } else {
            decompressed[decompressed_index++] = compressed_data[i++];
        }
    }

    decompressed = (unsigned char*)realloc(decompressed, decompressed_index);
    *decompressed_size = decompressed_index;

    return decompressed;
}
 



 Time: 2025-05-06 12:04:59.052036, Log:LLM response: 


 //INIZIO_FUNZIONE_COMPRESSIONE
unsigned char* compress(const unsigned char* data, size_t data_size, size_t* compressed_size) {
    unsigned char* compressed = (unsigned char*)malloc(data_size * 2);
    if (compressed == NULL) return NULL;

    size_t compressed_index = 0;
    size_t i = 0;

    // Rilevamento di sequenze ripetute
    while (i < data_size) {
        unsigned char current = data[i];
        unsigned char count = 1;

        // Rileva sequenze ripetute
        while (i + 1 < data_size && data[i + 1] == current && count < 255) {
            count++;
            i++;
        }

        // Compressione con RLE
        compressed[compressed_index++] = count;
        compressed[compressed_index++] = current;

        i++;
    }

    // Ottimizzazione della memoria allocata
    compressed = (unsigned char*)realloc(compressed, compressed_index);
    *compressed_size = compressed_index;

    return compressed;
}
//FINE_FUNZIONE_COMPRESSIONE

//INIZIO_FUNZIONE_DECOMPRESSIONE
unsigned char* decompress(const unsigned char* compressed_data, size_t compressed_size, size_t* decompressed_size) {
    size_t max_size = compressed_size * 255; 
    unsigned char* decompressed = (unsigned char*)malloc(max_size);
    if (decompressed == NULL) return NULL;

    size_t decompressed_index = 0;
    size_t i = 0;

    // Decompressione RLE
    while (i < compressed_size) {
        unsigned char count = compressed_data[i++];
        unsigned char value = compressed_data[i++];

        // Ripete il valore 'count' volte
        for (unsigned char j = 0; j < count; j++) {
            decompressed[decompressed_index++] = value;
        }
    }

    // Ridimensiona alla dimensione effettiva
    decompressed = (unsigned char*)realloc(decompressed, decompressed_index);
    *decompressed_size = decompressed_index;

    return decompressed;
}
//FINE_FUNZIONE_DECOMPRESSIONE 



 Time: 2025-05-06 12:04:59.052105, Log:Extracting evolved functions from LLM response
 Time: 2025-05-06 12:04:59.052145, Log:Compression function extracted: 


 unsigned char* compress(const unsigned char* data, size_t data_size, size_t* compressed_size) {
    unsigned char* compressed = (unsigned char*)malloc(data_size * 2);
    if (compressed == NULL) return NULL;

    size_t compressed_index = 0;
    size_t i = 0;

    // Rilevamento di sequenze ripetute
    while (i < data_size) {
        unsigned char current = data[i];
        unsigned char count = 1;

        // Rileva sequenze ripetute
        while (i + 1 < data_size && data[i + 1] == current && count < 255) {
            count++;
            i++;
        }

        // Compressione con RLE
        compressed[compressed_index++] = count;
        compressed[compressed_index++] = current;

        i++;
    }

    // Ottimizzazione della memoria allocata
    compressed = (unsigned char*)realloc(compressed, compressed_index);
    *compressed_size = compressed_index;

    return compressed;
}
 



 Time: 2025-05-06 12:04:59.052176, Log:Decompression function extracted: 


 unsigned char* decompress(const unsigned char* compressed_data, size_t compressed_size, size_t* decompressed_size) {
    size_t max_size = compressed_size * 255; 
    unsigned char* decompressed = (unsigned char*)malloc(max_size);
    if (decompressed == NULL) return NULL;

    size_t decompressed_index = 0;
    size_t i = 0;

    // Decompressione RLE
    while (i < compressed_size) {
        unsigned char count = compressed_data[i++];
        unsigned char value = compressed_data[i++];

        // Ripete il valore 'count' volte
        for (unsigned char j = 0; j < count; j++) {
            decompressed[decompressed_index++] = value;
        }
    }

    // Ridimensiona alla dimensione effettiva
    decompressed = (unsigned char*)realloc(decompressed, decompressed_index);
    *decompressed_size = decompressed_index;

    return decompressed;
}
 



 Time: 2025-05-06 12:04:59.052213, Log:Replacing functions in code with new functions.
 Time: 2025-05-06 12:04:59.052258, Log:Replacing functions in code with new functions.
 Time: 2025-05-06 12:04:59.052334, Log:Evaluating individual 0/2...
 Time: 2025-05-06 12:04:59.052361, Log:Compiling and testing code.
 Time: 2025-05-06 12:04:59.052444, Log:Write to file temp_compression.c
 Time: 2025-05-06 12:04:59.052517, Log:Compiling code
 Time: 2025-05-06 12:04:59.197173, Log:Running tests
 Time: 2025-05-06 12:04:59.197242, Log:Running test on file dataset2.txt
 Time: 2025-05-06 12:04:59.224986, Log:Test output: 


 Dimensione originale: 557964 bytes
Dimensione compressa: 1096068 bytes
Rapporto di compressione: 0.509060
Tempo di compressione: 0.001219 secondi
Tempo di decompressione: 0.001252 secondi
Controllo integrità: SUCCESSO
Memoria utilizzata (stima): 1615.27 KB
Punteggio fitness: 25.96
 



 Time: 2025-05-06 12:04:59.225067, Log:Parsing test output: 


 Dimensione originale: 557964 bytes
Dimensione compressa: 1096068 bytes
Rapporto di compressione: 0.509060
Tempo di compressione: 0.001219 secondi
Tempo di decompressione: 0.001252 secondi
Controllo integrità: SUCCESSO
Memoria utilizzata (stima): 1615.27 KB
Punteggio fitness: 25.96
 



 Time: 2025-05-06 12:04:59.225087, Log:Parsing test output: Rapporto di compressione
 Time: 2025-05-06 12:04:59.225234, Log:Compression ratio: 0.509060
 Time: 2025-05-06 12:04:59.225270, Log:Parsing test output: Tempo di compressione e decompressione
 Time: 2025-05-06 12:04:59.225371, Log:Compression time: 0.001219
 Time: 2025-05-06 12:04:59.225406, Log:Parsing test output: Tempo di decompressione
 Time: 2025-05-06 12:04:59.225488, Log:Decompression time: 0.001252
 Time: 2025-05-06 12:04:59.225524, Log:Parsing test output: Controllo integrità
 Time: 2025-05-06 12:04:59.225607, Log:Integrity check: SUCCESSO
 Time: 2025-05-06 12:04:59.225643, Log:Parsing test output: Punteggio fitness
 Time: 2025-05-06 12:04:59.225718, Log:Fitness score: 25.96
 Time: 2025-05-06 12:04:59.225797, Log:Calculating average fitness
 Time: 2025-05-06 12:04:59.225824, Log:Average fitness: 25.96, Compression ratio: 0.50906, Compression time: 0.001219, Decompression time: 0.001252, Integrity check: True
 Time: 2025-05-06 12:04:59.225867, Log:New best individual found
 Time: 2025-05-06 12:04:59.225951, Log:Evaluating individual 1/2...
 Time: 2025-05-06 12:04:59.225969, Log:Compiling and testing code.
 Time: 2025-05-06 12:04:59.226005, Log:Write to file temp_compression.c
 Time: 2025-05-06 12:04:59.226036, Log:Compiling code
 Time: 2025-05-06 12:04:59.355471, Log:Running tests
 Time: 2025-05-06 12:04:59.355543, Log:Running test on file dataset2.txt
 Time: 2025-05-06 12:04:59.383715, Log:Test output: 


 Dimensione originale: 557964 bytes
Dimensione compressa: 1096068 bytes
Rapporto di compressione: 0.509060
Tempo di compressione: 0.001229 secondi
Tempo di decompressione: 0.001268 secondi
Controllo integrità: SUCCESSO
Memoria utilizzata (stima): 1615.27 KB
Punteggio fitness: 25.96
 



 Time: 2025-05-06 12:04:59.383837, Log:Parsing test output: 


 Dimensione originale: 557964 bytes
Dimensione compressa: 1096068 bytes
Rapporto di compressione: 0.509060
Tempo di compressione: 0.001229 secondi
Tempo di decompressione: 0.001268 secondi
Controllo integrità: SUCCESSO
Memoria utilizzata (stima): 1615.27 KB
Punteggio fitness: 25.96
 



 Time: 2025-05-06 12:04:59.383888, Log:Parsing test output: Rapporto di compressione
 Time: 2025-05-06 12:04:59.383923, Log:Compression ratio: 0.509060
 Time: 2025-05-06 12:04:59.383966, Log:Parsing test output: Tempo di compressione e decompressione
 Time: 2025-05-06 12:04:59.383992, Log:Compression time: 0.001229
 Time: 2025-05-06 12:04:59.384006, Log:Parsing test output: Tempo di decompressione
 Time: 2025-05-06 12:04:59.384022, Log:Decompression time: 0.001268
 Time: 2025-05-06 12:04:59.384035, Log:Parsing test output: Controllo integrità
 Time: 2025-05-06 12:04:59.384050, Log:Integrity check: SUCCESSO
 Time: 2025-05-06 12:04:59.384063, Log:Parsing test output: Punteggio fitness
 Time: 2025-05-06 12:04:59.384077, Log:Fitness score: 25.96
 Time: 2025-05-06 12:04:59.384140, Log:Calculating average fitness
 Time: 2025-05-06 12:04:59.384165, Log:Average fitness: 25.96, Compression ratio: 0.50906, Compression time: 0.001229, Decompression time: 0.001268, Integrity check: True
 Time: 2025-05-06 12:04:59.384311, Log:Evaluating individual 2/2...
 Time: 2025-05-06 12:04:59.384359, Log:Compiling and testing code.
 Time: 2025-05-06 12:04:59.384402, Log:Write to file temp_compression.c
 Time: 2025-05-06 12:04:59.384443, Log:Compiling code
 Time: 2025-05-06 12:04:59.516465, Log:Running tests
 Time: 2025-05-06 12:04:59.516537, Log:Running test on file dataset2.txt
 Time: 2025-05-06 12:04:59.940076, Log:Test output: 


 Dimensione originale: 557964 bytes
Dimensione compressa: 557550 bytes
Rapporto di compressione: 1.000743
Tempo di compressione: 0.001058 secondi
Tempo di decompressione: 0.039681 secondi
Controllo integrità: FALLITO
Memoria utilizzata (stima): 23411.72 KB
Punteggio fitness: 0.00
 



 Time: 2025-05-06 12:04:59.940189, Log:Parsing test output: 


 Dimensione originale: 557964 bytes
Dimensione compressa: 557550 bytes
Rapporto di compressione: 1.000743
Tempo di compressione: 0.001058 secondi
Tempo di decompressione: 0.039681 secondi
Controllo integrità: FALLITO
Memoria utilizzata (stima): 23411.72 KB
Punteggio fitness: 0.00
 



 Time: 2025-05-06 12:04:59.940225, Log:Parsing test output: Rapporto di compressione
 Time: 2025-05-06 12:04:59.940256, Log:Compression ratio: 1.000743
 Time: 2025-05-06 12:04:59.940271, Log:Parsing test output: Tempo di compressione e decompressione
 Time: 2025-05-06 12:04:59.940287, Log:Compression time: 0.001058
 Time: 2025-05-06 12:04:59.940300, Log:Parsing test output: Tempo di decompressione
 Time: 2025-05-06 12:04:59.940314, Log:Decompression time: 0.039681
 Time: 2025-05-06 12:04:59.940328, Log:Parsing test output: Controllo integrità
 Time: 2025-05-06 12:04:59.940342, Log:Integrity check: FALLITO
 Time: 2025-05-06 12:04:59.940354, Log:Parsing test output: Punteggio fitness
 Time: 2025-05-06 12:04:59.940368, Log:Fitness score: 0.00
 Time: 2025-05-06 12:04:59.940443, Log:Calculating average fitness
 Time: 2025-05-06 12:04:59.940485, Log:Average fitness: 0.0, Compression ratio: 1.000743, Compression time: 0.001058, Decompression time: 0.039681, Integrity check: False
 Time: 2025-05-06 12:04:59.940636, Log:Evolution completed! Best fitness achieved: 25.96
 Time: 2025-05-06 12:04:59.941451, Log:Write to file evolved_compression.c